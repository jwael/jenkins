import io.mockk.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.time.Instant
import kotlin.test.assertEquals

class HandleClsContactRequestUseCaseTest {

    private val crmClsContactDataRepositorySpi: CrmClsContactDataRepositorySpi = mockk()
    private val clsProviderSpi: ClsProviderSpi = mockk()
    private val recordStepEventRepositorySpi: RecordStepEventRepositorySpi = mockk()
    private val clockProvider: ClockProvider = mockk()

    private lateinit var useCase: HandleClsContactRequestUseCase

    // ✅ Référence de 10 caractères et code ISO 3166 valide
    private val batchReference = ReferenceId("BATCH00001")
    private val rowReference = ReferenceId("ROW000001")
    private val reconciliationId = ReconciliationId(batchReference, rowReference)
    private val countryCode = CountryCode("FR")

    private val clsId = "CLS123456"
    private val contactRoleSalesForceId = "ROLE001"

    private val clsContactDataRequestPayload = ClsContactDataRequestPayLoad(
        countryCode = countryCode,
        reconciliationId = reconciliationId,
        clsId = clsId,
        contactRoleSalesForceId = contactRoleSalesForceId
    )

    private val contactEntity = CrmClsContactData(
        id = "CUST000001",
        batchId = batchReference.value,
        reconciliationId = reconciliationId,
        rowNumber = 1,
        rowReference = rowReference,
        crmData = CrmData(),
        clsData = emptyMap(),
        crmInsertedId = null
    )

    @BeforeEach
    fun setup() {
        clearMocks(crmClsContactDataRepositorySpi, clsProviderSpi, recordStepEventRepositorySpi, clockProvider)
        useCase = HandleClsContactRequestUseCase(
            crmClsContactDataRepositorySpi,
            clsProviderSpi,
            recordStepEventRepositorySpi,
            clockProvider
        )
    }

    @Test
    @DisplayName("it should enrich CLS data, send to CLS, and save step event")
    fun `should enrich contact and call CLS provider`() {
        // GIVEN
        every { crmClsContactDataRepositorySpi.findByReconciliationId(reconciliationId) } returns contactEntity
        every { clsProviderSpi.sendContactToCls(any(), countryCode) } just Runs
        every { recordStepEventRepositorySpi.save(any()) } just Runs
        every { clockProvider.now() } returns Instant.now()

        // WHEN
        useCase.invoke(clsContactDataRequestPayload)

        // THEN
        verify(exactly = 1) { crmClsContactDataRepositorySpi.findByReconciliationId(reconciliationId) }
        verify(exactly = 1) {
            clsProviderSpi.sendContactToCls(
                match { it.clsData["CLS_ID"] == clsId && it.reconciliationId == reconciliationId },
                countryCode
            )
        }
        verify(exactly = 1) {
            recordStepEventRepositorySpi.save(
                match {
                    it.batchId == batchReference.value &&
                    it.rowNumber == contactEntity.rowNumber &&
                    it.reconciliationId == reconciliationId &&
                    it.stepName == RecordStepName.CLS_SENDING &&
                    it.stepStatus == RecordStepStatus.OK
                }
            )
        }
    }

    @Test
    @DisplayName("it should warn if contact not found")
    fun `should warn when contact is not found`() {
        // GIVEN
        every { crmClsContactDataRepositorySpi.findByReconciliationId(reconciliationId) } returns null
        every { clockProvider.now() } returns Instant.now()

        // WHEN
        useCase.invoke(clsContactDataRequestPayload)

        // THEN
        verify(exactly = 1) { crmClsContactDataRepositorySpi.findByReconciliationId(reconciliationId) }
        verify(exactly = 0) { clsProviderSpi.sendContactToCls(any(), any()) }
        verify(exactly = 0) { recordStepEventRepositorySpi.save(any()) }
    }
}