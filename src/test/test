import io.mockk.*
import kotlinx.coroutines.runBlocking
import org.instancio.Instancio
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import java.time.Instant
import java.time.LocalDate
import java.util.stream.IntStream

class ImportCustomerServiceTest {

    // Mocks
    private val referenceIdFactory: ReferenceIdFactory = mockk { }
    private val clockProvider: ClockProvider = mockk { every { now() } returns Instant.MIN }
    private val crmClsCustomerDataRepositorySpi: CrmClsCustomerDataRepositorySpi = mockk()
    private val batchRepositorySpi: BatchRepositoryForContactsSpi = mockk()
    private val crmCustomerProviderSpi: CrmCustomerProviderSpi = mockk()
    private val recordStepEventRepositorySpi: RecordStepEventRepositorySpi = mockk(relaxed = true)

    // Classe sous test
    private val importCustomerService = ImportCustomerService(
        referenceIdFactory = referenceIdFactory,
        clockProvider = clockProvider,
        crmClsCustomerDataRepositorySpi = crmClsCustomerDataRepositorySpi,
        batchRepositorySpi = batchRepositorySpi,
        crmCustomerProviderSpi = crmCustomerProviderSpi,
        recordStepEventRepositorySpi = recordStepEventRepositorySpi
    )

    // Batch factice
    private val batchReference = ReferenceId(value = "HVrA7jQziv")
    private val newBatch = LoaderBatch(
        id = "AAAAA",
        reference = batchReference,
        fileName = "a-file-name.csv",
        triggeredBy = "u00001",
        countryCode = CountryCode("GB"),
        status = LoaderBatchStatus.RUNNING
    )

    // Nombre de clients factices
    private val customerCount = 2

    // Génération de payloads factices avec Instancio
    private val customersToCreate = IntStream.range(0, customerCount).mapToObj { i ->
        CustomerPayload(
            rowNumber = i,
            errorMessage = null,
            crmData = Instancio.of(CrmData::class.java)
                .set(CrmData::firstName, "John$i")
                .set(CrmData::surname, "Doe$i")
                .set(CrmData::salutation, "Dr.")
                .set(CrmData::title, "Engineer")
                .set(CrmData::gender, "Male")
                .set(CrmData::contactRole, "Driver")
                .set(CrmData::mainCountry, "FRANCE")
                .set(CrmData::personalIdentificationNumber, "ID$i")
                .set(CrmData::customerProspect, "prospect")
                .set(CrmData::phone, "010203040$i")
                .set(CrmData::mobilePhone, "060708090$i")
                .set(CrmData::email, "john$i@email.fr")
                .set(CrmData::address1, "Street 1")
                .set(CrmData::address2, "Street 2")
                .set(CrmData::postalCode, "75000")
                .set(CrmData::state, "State")
                .set(CrmData::country, "FR")
                .set(CrmData::businessType, "TypeA")
                .set(CrmData::birthDate, LocalDate.of(1980, 1, 1))
                .create(),
            clsData = emptyMap()
        )
    }.toList()



toList()

    @Nested
    inner class DriveCases {

        @Test
        fun `should process all customers successfully`() = runBlocking {
            // Arrange
            every { batchRepositorySpi.save(any()) } answers { firstArg() }
            every { recordStepEventRepositorySpi.save(any()) } just Runs
            every { crmClsCustomerDataRepositorySpi.saveAll(any()) } returns customersToCreate

            // Act
            importCustomerService.apply(newBatch, customersToCreate)

            // Assert
            verify(exactly = 1) { batchRepositorySpi.save(any()) }
            verify(atLeast = 1) { recordStepEventRepositorySpi.save(any()) }
            verify(exactly = 1) { crmClsCustomerDataRepositorySpi.saveAll(any()) }
        }

        @ParameterizedTest
        @CsvSource(
            "John, Doe",
            "Jane, Smith",
            "Pierre, Dupont"
        )
        fun `should handle different customer names`(firstName: String, surname: String) = runBlocking {
            // Arrange
            every { batchRepositorySpi.save(any()) } answers { firstArg() }
            every { recordStepEventRepositorySpi.save(any()) } just Runs
            every { crmClsCustomerDataRepositorySpi.saveAll(any()) } returns emptyList()

            val payload = CustomerPayload(
                rowNumber = 1,
                crmData = CrmData(
                    firstName = firstName,
                    surname = surname,
                    mainCountry = "FRANCE",
                    country = "FR"
                ),
                clsData = emptyMap(),
                errorMessage = null
            )

            // Act
            importCustomerService.apply(newBatch, listOf(payload))

            // Assert
            verify { batchRepositorySpi.save(any()) }
            verify { recordStepEventRepositorySpi.save(any()) }
        }

        @Test
        fun `should skip customer with missing mandatory data`() = runBlocking {
            // Arrange : customer sans prénom/nom
            val invalidPayload = CustomerPayload(
                rowNumber = 99,
                crmData = CrmData(
                    firstName = null,
                    surname = null,
                    mainCountry = "FRANCE",
                    country = "FR"
                ),
                clsData = emptyMap(),
                errorMessage = null
            )
            every { batchRepositorySpi.save(any()) } answers { firstArg() }
            every { recordStepEventRepositorySpi.save(any()) } just Runs

            // Act
            importCustomerService.apply(newBatch, listOf(invalidPayload))

            // Assert : on s’attend à ce que l’événement d’erreur soit enregistré
            verify { recordStepEventRepositorySpi.save(any()) }
            confirmVerified(crmClsCustomerDataRepositorySpi)
        }

        @Test
        fun `should process empty customer list without error`() = runBlocking {
            // Arrange
            every { batchRepositorySpi.save(any()) } answers { firstArg() }
            every { recordStepEventRepositorySpi.save(any()) } just Runs

            // Act
            importCustomerService.apply(newBatch, emptyList())

            // Assert
            verify { batchRepositorySpi.save(any()) }
            verify { recordStepEventRepositorySpi.save(any()) }
        }
    }
}





    @Nested
    inner class DriveCases {

        @Test
        fun `should process all customers successfully`() = runBlocking {
            importCustomerService.apply(newBatch, customersToCreate)
            verify { recordStepEventRepositorySpi.save(any()) }
        }

        @ParameterizedTest
        @CsvSource(
            "John, Doe",
            "Jane, Smith"
        )
        fun `should handle different customer names`(firstName: String, surname: String) = runBlocking {
            val payload = CustomerPayload(
                rowNumber = 1,
                crmData = CrmData(
                    firstName = firstName,
                    surname = surname,
                    mainCountry = "FRANCE",
                    country = "FR"
                ),
                clsData = emptyMap(),
                errorMessage = null
            )
            importCustomerService.apply(newBatch, listOf(payload))
            verify { recordStepEventRepositorySpi.save(any()) }
        }
    }
}